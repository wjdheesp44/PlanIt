<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "https://mybatis.org/dtd/mybatis-3-mapper.dtd">
<mapper namespace="com.gt.planit.domain.spot.model.mapper.SpotMapper">

    <sql id="spotSelectColumns">
        s.id                                                AS id,
        s.title                                             AS name,
        CASE s.content_type
            WHEN 'ATTRACTION' THEN '관광지'
            WHEN 'FESTIVAL'  THEN '축제'
            WHEN 'POPUP'     THEN '팝업'
        END                                                 AS badge,
        s.avg_rating                                        AS rating,
        CASE
            WHEN s.start_time IS NULL OR s.end_time IS NULL THEN '상시운영'
            ELSE CONCAT(
                DATE_FORMAT(s.start_time, '%Y년 %c월 %e일'),
                ' ~ ',
                DATE_FORMAT(s.end_time, '%Y년 %c월 %e일')
            )
        END                                                  AS time,
        COALESCE(s.doro_addr, s.jibun_addr)                 AS location,
        TRIM(
            COALESCE(
                GROUP_CONCAT(DISTINCT CONCAT('#', rh.hashtag) SEPARATOR ' '),
                ''
            )
        )                                                   AS tags,
        s.image1                                            AS image,
        COALESCE(sl.likes_count, 0)                         AS likesCount,
        0                                                   AS favorite
    </sql>

    <!-- 공통 FROM / JOIN -->
    <sql id="spotFromWithJoins">
        FROM spots s
        LEFT JOIN reviews r
        ON r.spot_id = s.id
        AND r.is_deleted = 'F'
        LEFT JOIN review_hashtags rh
        ON rh.review_id = r.id
        AND rh.is_deleted = 'F'
        LEFT JOIN (
        SELECT spot_id, COUNT(*) AS likes_count
        FROM spot_likes
        WHERE is_deleted = 'F'
        GROUP BY spot_id
        ) sl
        ON sl.spot_id = s.id
    </sql>

    <!-- 공통 WHERE 조건 -->
    <sql id="spotWhere">
        WHERE s.is_deleted = 'F'

        <!-- type → content_type ENUM (ATTRACTION/FESTIVAL/POPUP)로 매핑해서 넣는다고 가정 -->
        <if test="cond.types != null and cond.types.size() > 0">
            AND s.content_type IN
            <foreach collection="cond.types" item="t" open="(" separator="," close=")">
                #{t}
            </foreach>
        </if>

        <!-- 기간 -->
        <if test="cond.startDate != null and cond.endDate != null">
            AND (
            (s.start_time IS NULL AND s.end_time IS NULL)  <!-- 상시 운영 -->
            OR (
            s.start_time &lt;= #{cond.endDate}  <!-- 이벤트 시작이 여행 종료 이전 -->
            AND
            (s.end_time IS NULL OR s.end_time &gt;= #{cond.startDate})  <!-- 이벤트 종료가 여행 시작 이후 -->
            )
            )
        </if>

        <!-- 날씨 필터 (WeatherService와 동일한 대표 날씨 로직) -->
        <if test="cond.weathers != null and cond.weathers.size() > 0 and cond.startDate != null and cond.endDate != null">
            AND NOT EXISTS (
            SELECT 1
            FROM (
            SELECT
            wf.forecast_date,
            COALESCE(
            -- 1순위: 12시~18시 사이 예보 중 가장 이른 시간
            (
            SELECT weather_condition
            FROM weather_forecasts
            WHERE gugun_id = wf.gugun_id
            AND forecast_type = 'SHORT_TERM'
            AND forecast_date = wf.forecast_date
            AND CAST(forecast_time AS UNSIGNED) BETWEEN 1200 AND 1800
            ORDER BY forecast_time ASC
            LIMIT 1
            ),
            -- 2순위: 아무거나 첫 번째
            (
            SELECT weather_condition
            FROM weather_forecasts
            WHERE gugun_id = wf.gugun_id
            AND forecast_type = 'SHORT_TERM'
            AND forecast_date = wf.forecast_date
            LIMIT 1
            )
            ) as rep_weather
            FROM weather_forecasts wf
            WHERE wf.gugun_id = s.si_gun_gu_id
            AND wf.forecast_type = 'SHORT_TERM'
            AND wf.forecast_date BETWEEN #{cond.startDate} AND #{cond.endDate}
            GROUP BY wf.forecast_date, wf.gugun_id
            ) daily
            WHERE
            daily.rep_weather IS NULL
            OR daily.rep_weather NOT IN
            <foreach collection="cond.weathers" item="w" open="(" separator="," close=")">
                #{w}
            </foreach>
            )
        </if>




        <!-- 평점 다중 선택 -->
        <if test="cond.ratings != null and cond.ratings.size() &gt; 0">
            AND (
            <foreach collection="cond.ratings" item="r" separator=" OR ">
                (s.avg_rating &gt;= #{r} AND s.avg_rating &lt; #{r} + 1)
            </foreach>
            )
        </if>

        <!-- 최소 좋아요 수 -->
        <if test="cond.likesCountMin != null">
            AND COALESCE(sl.likes_count, 0) &gt;= #{cond.likesCountMin}
        </if>

        <!-- 검색어 -->
        <if test="cond.searchKeyword != null and cond.searchKeyword != ''">
            AND (
            s.title      LIKE CONCAT('%', #{cond.searchKeyword}, '%')
            OR s.overview LIKE CONCAT('%', #{cond.searchKeyword}, '%')
            OR s.doro_addr LIKE CONCAT('%', #{cond.searchKeyword}, '%')
            OR s.jibun_addr LIKE CONCAT('%', #{cond.searchKeyword}, '%')
            )
        </if>

        <!-- 태그 다중 선택 (리뷰 해시태그 기준 OR) -->
        <if test="cond.tags != null and cond.tags.size() &gt; 0">
            AND (
            <foreach collection="cond.tags" item="t" separator=" OR ">
                rh.hashtag LIKE CONCAT('%', #{t}, '%')
            </foreach>
            )
        </if>

        <!-- regionIds: gugun_id 기준 -->
        <if test="cond.regionIds != null and cond.regionIds.size() &gt; 0">
            AND s.si_gun_gu_id IN
            <foreach collection="cond.regionIds" item="rid" open="(" separator="," close=")">
                #{rid}
            </foreach>
        </if>
    </sql>

    <!-- 공통 ORDER BY -->
    <sql id="spotOrderBy">
        <choose>
            <when test="cond.sort == 'LIKES_DESC'">
                ORDER BY COALESCE(sl.likes_count, 0) DESC, s.id ASC
            </when>
            <when test="cond.sort == 'RATING_DESC'">
                ORDER BY s.avg_rating DESC, s.id ASC
            </when>
            <when test="cond.sort == 'LATEST'">
                ORDER BY s.end_time DESC, s.id ASC
            </when>
            <otherwise>
                ORDER BY s.id ASC
            </otherwise>
        </choose>
    </sql>

    <!-- 리스트 조회 -->
    <select id="searchSpots"
            resultType="com.gt.planit.domain.spot.model.dto.SpotRes">
        SELECT
        <include refid="spotSelectColumns"/>
        <include refid="spotFromWithJoins"/>
        <include refid="spotWhere"/>
        GROUP BY
        s.id, s.title, s.content_type, s.avg_rating,
        s.start_time, s.end_time, s.doro_addr, s.image1
        <include refid="spotOrderBy"/>
        LIMIT #{limit} OFFSET #{offset}
    </select>

    <!-- 전체 개수 -->
    <select id="countSpots" resultType="long">
        SELECT COUNT(DISTINCT s.id)
        <include refid="spotFromWithJoins"/>
        <include refid="spotWhere"/>
    </select>

    <!-- 좋아요한 스팟 ID 목록 조회 (IN 절 사용) -->
    <select id="selectLikedSpotIds" resultType="long">
        SELECT spot_id
        FROM spot_likes
        WHERE user_id = #{userId}
        AND is_deleted = 'F'
        AND spot_id IN
        <foreach collection="spotIds" item="spotId" open="(" separator="," close=")">
            #{spotId}
        </foreach>
    </select>

    <!-- 여기부터 스팟 상세 조회 -->
    <select id="selectSpotDetailById" resultType="com.gt.planit.domain.spot.model.dto.SpotDetailResDto">
        SELECT
        s.id,
        s.title,
        CASE s.content_type
        WHEN 'ATTRACTION' THEN '관광지'
        WHEN 'FESTIVAL'  THEN '축제'
        WHEN 'POPUP'     THEN '팝업'
        END AS badge,
        s.avg_rating as avgRating,
        COALESCE(s.rating_count, 0) as reviewCount,
        CASE
        WHEN s.start_time IS NULL OR s.end_time IS NULL THEN '상시운영'
        ELSE CONCAT(
        DATE_FORMAT(s.start_time, '%Y년 %c월 %e일'),
        ' ~ ',
        DATE_FORMAT(s.end_time, '%Y년 %c월 %e일')
        )
        END                                                  AS date,
        s.doro_addr as doroAddr,
        s.jibun_addr as jibunAddr,
        s.latitude,
        s.longitude,
        s.tel,
        s.homepage,
        s.image1,
        s.image2,
        s.image3,
        s.image4,
        s.image5,
        s.overview as description,
        s.sido_id as sidoId,
        s.si_gun_gu_id as gugunId,
        COALESCE(sl.likes_count, 0) AS likesCount
        FROM spots s
        LEFT JOIN (
        SELECT spot_id, COUNT(*) AS likes_count
        FROM spot_likes
        WHERE is_deleted = 'F'
        GROUP BY spot_id
        ) sl ON sl.spot_id = s.id
        WHERE s.id = #{spotId}
        AND s.is_deleted = 'F'
    </select>

    <!-- 좋아요 여부 체크 -->
    <select id="checkSpotLike" resultType="boolean">
        SELECT EXISTS(
        SELECT 1
        FROM spot_likes
        WHERE spot_id = #{spotId}
        AND user_id = #{userId}
        AND is_deleted = 'F'
        )
    </select>

    <!-- 같은 시/도의 핫스팟 랜덤 조회 -->
    <select id="selectRandomHotSpotsBySido" resultType="com.gt.planit.domain.spot.model.dto.SpotRes">
        SELECT
        s.id,
        s.title AS name,
        s.image1 AS image,
        CASE s.content_type
        WHEN 'ATTRACTION' THEN '관광지'
        WHEN 'FESTIVAL'  THEN '축제'
        WHEN 'POPUP'     THEN '팝업'
        END AS badge,
        COALESCE(NULLIF(s.doro_addr, ''), s.jibun_addr) AS location,
        s.avg_rating AS rating,
        CASE
            WHEN s.start_time IS NULL OR s.end_time IS NULL THEN '상시운영'
            ELSE CONCAT(
                DATE_FORMAT(s.start_time, '%Y년 %c월 %e일'),
                ' ~ ',
                DATE_FORMAT(s.end_time, '%Y년 %c월 %e일')
            )
        END                                                  AS time,
        NULL AS tags,
        FALSE AS favorite
        FROM spots s
        WHERE s.sido_id = #{sidoId}
        AND s.image1 IS NOT NULL
        AND s.image1 != ''
        AND s.id != #{excludeSpotId}
        AND s.is_deleted = 'F'
        ORDER BY RAND()
        LIMIT #{limit}
    </select>

    <!-- 조회수 기록 -->
    <insert id="insertSpotView">
        INSERT INTO spot_views (spot_id, created_at, user_id)
        VALUES (#{spotId}, NOW(), #{userId})
    </insert>
</mapper>